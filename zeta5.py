class zeta5:
    """creates elements in the quadatic extension generated by the golden
    ratio (1+sqrt(5))/2.  (This is relevant for Coxeter groups of type
    H_3 and H_4.) Any such element is represented as

              a + b * (1+sqrt(5))/2   where  a,b are integers.

    There is an optional argument 'iname' by which one can specify how
    (1+sqrt(5))/2 is printed; the default value is 'ir5'.

    >>> zeta5(1,1)
    1+ir5
    >>> zeta5(0,1)*zeta5(0,1)-zeta5(0,1)-1
    0
    >>> (2*zeta5(0,1)-1)**2
    5
    >>> from chv1r6180 import coxeter
    >>> W = coxeter("H",3)
    >>> W.roots[:W.N]
    [(1, 0, 0), (0, 1, 0), (0, 0, 1), (0, 1, 1), (ir5, 1, 0),
    (1, ir5, 0), (ir5, ir5, 0), (ir5, 1, 1), (1, ir5, ir5), (ir5, ir5, ir5),
    (ir5, 1+ir5, 1), (ir5, 1+ir5, ir5), (1+ir5, 1+ir5, 1),
    (1+ir5, 1+ir5, ir5), (1+ir5, 2*ir5, ir5)]
    """

    def __init__(self, a, b, iname='ir5'):
        self.a = a
        self.b = b
        self.ir5 = iname

    def __repr__(self):
        if self.b == 0:
            return repr(self.a)
        else:
            if self.a == 0:
                r = ''
            else:
                if self.b > 0:
                    r = repr(self.a) + '+'
                else:
                    if type(self.b) == type(0):
                        r = repr(self.a)
                    else:
                        r = repr(self.a) + '+'
            if self.b == 1:
                r += self.ir5
            elif self.b > 1:
                r += repr(self.b) + '*' + self.ir5
            elif self.b == -1:
                r += '-' + self.ir5
            else:
                r += repr(self.b) + '*' + self.ir5
            return r

    def __eq__(self, f):
        if type(f) == type(0):
            return self.a == f and self.b == 0
        elif type(self) == type(f) and self.__class__ == f.__class__:
            return self.a == f.a and self.b == f.b
        else:
            return False

    def __ne__(self, f):
        return not self == f

    def __gt__(self, f):
        if type(f) == type(0):
            c = self.a - f
            d = self.b
        else:
            c = self.a - f.a
            d = self.b - f.b
        return c + 1.618033988749895 * d > 0

    def __lt__(self, f):
        if type(f) == type(0):
            c = self.a - f
            d = self.b
        else:
            c = self.a - f.a
            d = self.b - f.b
        return c + 1.618033988749895 * d < 0

    def __ge__(self, f):
        return self == f or self > f

    def __le__(self, f):
        return self == f or self < f

    def __neg__(self):
        return zeta5(-self.a, -self.b, iname=self.ir5)

    def __add__(self, f):
        # if type(f)!=type(self):
        if type(f) == type(0):
            return zeta5(self.a + f, self.b, iname=self.ir5)
        else:
            if self.b == -f.b:
                return self.a + f.a
            else:
                return zeta5(self.a + f.a, self.b + f.b, iname=self.ir5)

    def __radd__(self, f):
        return self + f

    def __sub__(self, f):
        return self + (-f)

    def __rsub__(self, f):
        return f + (-self)

    def __mul__(self, f):
        if type(f) == type(0):
            if f == 0:
                return 0
            else:
                return zeta5(self.a * f, self.b * f, iname=self.ir5)
        elif type(self) == type(f) and self.__class__ == f.__class__:
            x = self.a * f.b + self.b * f.a + self.b * f.b
            if x == 0:
                return self.a * f.a + self.b * f.b
            else:
                return zeta5(self.a * f.a + self.b * f.b, x, iname=self.ir5)
        else:
            return f * self

    def __rmul__(self, f):
        if type(f) != type(self):
            if f == 0:
                return 0
            else:
                return zeta5(self.a * f, self.b * f, iname=self.ir5)
        else:
            return zeta5(self.a * f.a + self.b * f.b,
                         self.a * f.b + self.b * f.a + self.b * f.b, iname=self.ir5)

    def __pow__(self, n):
        if n == 0:
            return 1
        elif n == 1:
            return self
        elif n == -1:
            N = self.a**2 - self.b**2 + self.a * self.b
            if (self.a - self.b) % N == 0 and self.b % N == 0:
                return zeta5((self.a + self.b) // N, -self.b // N)
            else:
                from fractions import Fraction
                return zeta5(Fraction(self.a + self.b, N), -Fraction(self.b, N))
        else:
            z = self
            for i in range(1, n):
                z *= self
            return z

    def __divmod__(self, f):
        if type(f) == type(0):
            N = f
            x, y = self.a, self.b
        else:
            N = f.a**2 - f.b**2 + f.a * f.b
            x, y = self.a * f.a + self.a * f.b - self.b * f.b, f.a * self.b - self.a * f.b
        if x % N == 0 and y % N == 0:
            return (zeta5(x // N, y // N), 0)
        else:
            return (0, self)

    def __rdivmod__(self, f):
        if f == 0:
            return (0, 0)
        return divmod(f * zeta5(1, 0), self)

    def __floordiv__(self, f):
        return divmod(self, f)[0]

    def __rfloordiv__(self, f):
        return divmod(f * zeta5(1, 0), self)[0]

    def __mod__(self, f):
        return divmod(self, f)[1]

    def __rmod__(self, f):
        return divmod(f * zeta5(1, 0), self)[1]
